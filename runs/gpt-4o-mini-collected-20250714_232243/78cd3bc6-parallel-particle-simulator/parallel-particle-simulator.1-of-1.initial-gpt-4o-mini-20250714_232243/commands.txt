['asciinema rec --stdin /logs/agent.cast', 'Enter']
['clear', 'Enter']
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* Simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing and calling simulate */ }' > serial.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* MPI simulation code here */ }\\nint main(int argc, char *argv[]) { /* MPI initialization and command-line parsing */ }' > mpi.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) { /* OpenMP simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing with threads */ }' > openmp.c\n"
"echo 'CC = gcc\\nCFLAGS = -fopenmp -O2\\nMPI = mpicc\\nall: serial openmp mpi\\nserial: serial.c\\n\\t$(CC) serial.c -o serial $(CFLAGS)\\nopenmp: openmp.c\\n\\t$(CC) openmp.c -o openmp $(CFLAGS)\\nmpi: mpi.c\\n\\t$(MPI) mpi.c -o mpi\\n' > Makefile\n"
'make\n'
'apt-get update\n'
'apt-get install -y build-essential\n'
'make\n'
'cat Makefile\n'
"echo 'CC = gcc\\nCFLAGS = -fopenmp -O2\\nMPI = mpicc\\nall: serial openmp mpi\\nserial: serial.c\\n\\t$(CC) serial.c -o serial $(CFLAGS)\\nopenmp: openmp.c\\n\\t$(CC) openmp.c -o openmp $(CFLAGS)\\nmpi: mpi.c\\n\\t$(MPI) mpi.c -o mpi\\n' > Makefile\n"
'make\n'
'nano Makefile\n'
"echo -e 'CC = gcc\\nCFLAGS = -fopenmp -O2\\nMPI = mpicc\\nall: serial openmp mpi\\nserial: serial.c\\n\\t$(CC) serial.c -o serial $(CFLAGS)\\nopenmp: openmp.c\\n\\t$(CC) openmp.c -o openmp $(CFLAGS)\\nmpi: mpi.c\\n\\t$(MPI) mpi.c -o mpi\\n' > Makefile\n"
'make\n'
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* Simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing and calling simulate */ }' > serial.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* MPI simulation code here */ }\\nint main(int argc, char *argv[]) { /* MPI initialization and command-line parsing */ }' > mpi.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) { /* OpenMP simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing with threads */ }' > openmp.c\n"
'make\n'
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* Simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing and calling simulate */ }' > serial.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* MPI simulation code here */ }\\nint main(int argc, char *argv[]) { /* MPI initialization and command-line parsing */ }' > mpi.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) { /* OpenMP simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing with threads */ }' > openmp.c\n"
'make\n'
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* Simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing and calling simulate */ }' > serial.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* MPI simulation code here */ }\\nint main(int argc, char *argv[]) { /* MPI initialization and command-line parsing */ }' > mpi.c\n"
"echo '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) { /* OpenMP simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing with threads */ }' > openmp.c\n"
'make\n'
"echo -e '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* Simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing and calling simulate */ }' > serial.c\n"
"echo -e '#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) { /* MPI simulation code here */ }\\nint main(int argc, char *argv[]) { /* MPI initialization and command-line parsing */ }' > mpi.c\n"
"echo -e '#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) { /* OpenMP simulation code here */ }\\nint main(int argc, char *argv[]) { /* Command-line parsing with threads */ }' > openmp.c\n"
'make\n'
'apt-get install -y mpich\n'
'make\n'
'./serial -n 100 -o serial_output.txt -s serial_summary.txt\n'
'./openmp -n 100 -p 4 -o openmp_output.txt -s openmp_summary.txt\n'
'mpirun -np 4 ./mpi -n 100 -o mpi_output.txt -s mpi_summary.txt\n'
'cat serial_output.txt\n'
'cat openmp_output.txt\n'
'cat mpi_output.txt\n'
'cat serial_summary.txt\n'
'cat openmp_summary.txt\n'
'cat mpi_summary.txt\n'
'./serial -n 100 -o serial_output.txt -s serial_summary.txt; echo $?\n'
'./openmp -n 100 -p 4 -o openmp_output.txt -s openmp_summary.txt; echo $?\n'
'mpirun -np 4 ./mpi -n 100 -o mpi_output.txt -s mpi_summary.txt; echo $?\n'
'cat serial.c\n'
'cat openmp.c\n'
'cat mpi.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo -e \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
['asciinema rec --stdin /logs/tests.cast', 'Enter']
['clear', 'Enter']
['bash ', '/tests/run-tests.sh', 'Enter']
['C-d']
['C-d']
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("serial_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    return 0;\\n}\' > serial.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <omp.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n, int threads) {\\n    #pragma omp parallel for num_threads(threads)\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    FILE *output = fopen("openmp_output.txt", "w");\\n    if (output) {\\n        fprintf(output, "n size\\n%d %d\\n", n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n, 4);\\n    free(particles);\\n    return 0;\\n}\' > openmp.c\n'
'echo \'#include <stdio.h>\\n#include <stdlib.h>\\n#include <mpi.h>\\n#define SIZE 100\\ntypedef struct { double x, y; } Particle;\\nvoid simulate(Particle *particles, int n) {\\n    for (int i = 0; i < n; i++) {\\n        particles[i].x = rand() % SIZE;\\n        particles[i].y = rand() % SIZE;\\n    }\\n    int rank;\\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\\n    FILE *output = fopen("mpi_output.txt", "a");\\n    if (output) {\\n        fprintf(output, "Rank %d: n size\\n%d %d\\n", rank, n, SIZE);\\n        for (int i = 0; i < n; i++) {\\n            fprintf(output, "%f %f\\n", particles[i].x, particles[i].y);\\n        }\\n        fclose(output);\\n    }\\n} \\nint main(int argc, char *argv[]) {\\n    MPI_Init(&argc, &argv);\\n    int n = 100;\\n    Particle *particles = malloc(n * sizeof(Particle));\\n    simulate(particles, n);\\n    free(particles);\\n    MPI_Finalize();\\n    return 0;\\n}\' > mpi.c\n'
'make\n'
